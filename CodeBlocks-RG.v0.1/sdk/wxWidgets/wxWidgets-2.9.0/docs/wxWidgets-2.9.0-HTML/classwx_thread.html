<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: wxThread Class Reference</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Fri Sep 4 06:59:32 2009"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Categories</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>wxThread Class Reference<br>
<small>
[<a class="el" href="group__group__class__threading.html">Threading</a>]</small>
</h1><!-- doxytag: class="wxThread" --><code>#include &lt;wx/thread.h&gt;</code>
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A thread is basically a path of execution through a program. 
<p>
Threads are sometimes called <em>light-weight</em> processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space.<p>
While it makes it much easier to share common data between several threads, it also makes it much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it...">wxMutex</a>) or critical sections (see <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>) is recommended. In addition, don't create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system.<h2><a class="anchor" name="thread_types">
Types of wxThreads</a></h2>
There are two types of threads in wxWidgets: <em>detached</em> and <em>joinable</em>, modeled after the the POSIX thread API. This is different from the Win32 API where all threads are joinable.<p>
By default wxThreads in wxWidgets use the <b>detached</b> behavior. Detached threads delete themselves once they have completed, either by themselves when they complete processing or through a call to <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a>, and thus <b>must</b> be created on the heap (through the new operator, for example).<p>
Typically you'll want to store the instances of the detached wxThreads you allocate, so that you can call functions on them. Because of their nature however you'll need to always use a critical section when accessing them:<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// declare a new type of event, to be used by our MyThread class:</span>
    <a class="code" href="group__group__funcmacro__events.html#g767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>);
    <a class="code" href="group__group__funcmacro__events.html#g767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>);
    <span class="keyword">class </span>MyFrame;

    <span class="keyword">class </span>MyThread : <span class="keyword">public</span> <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a>
    {
    <span class="keyword">public</span>:
        MyThread(MyFrame *handler)
            : <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a>(<a class="code" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0cd9af5dbbc12a95684ab6e7be16e30c9" title="Detached thread.">wxTHREAD_DETACHED</a>)
            { m_pHandler = handler }
        ~MyThread();

    <span class="keyword">protected</span>:
        <span class="keyword">virtual</span> <a class="code" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">ExitCode</a> <a class="code" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry</a>();
        MyFrame *m_pHandler;
    };

    <span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>
    {
    <span class="keyword">public</span>:
        ...
        ~MyFrame()
        {
            <span class="comment">// it's better to do any thread cleanup in the OnClose()</span>
            <span class="comment">// event handler, rather than in the destructor.</span>
            <span class="comment">// This is because the event loop for a top-level window is not</span>
            <span class="comment">// active anymore when its destructor is called and if the thread</span>
            <span class="comment">// sends events when ending, they won't be processed unless</span>
            <span class="comment">// you ended the thread from OnClose.</span>
            <span class="comment">// See @ref overview_windowdeletion for more info.</span>
        }
        ...
        <span class="keywordtype">void</span> DoStartThread();
        <span class="keywordtype">void</span> DoPauseThread();

        <span class="comment">// a resume routine would be nearly identic to DoPauseThread()</span>
        <span class="keywordtype">void</span> DoResumeThread() { ... }

        <span class="keywordtype">void</span> OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>&amp;);
        <span class="keywordtype">void</span> OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>&amp;);
        <span class="keywordtype">void</span> OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;);

    <span class="keyword">protected</span>:
        MyThread *m_pThread;
        <a class="code" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a> m_pThreadCS;    <span class="comment">// protects the m_pThread pointer</span>

        <a class="code" href="group__group__funcmacro__events.html#g7c5c2ed4b4fcd9644d6f21c824721adf" title="Use this macro inside a class declaration to declare a static event table for that...">DECLARE_EVENT_TABLE</a>()
    };

    <a class="code" href="group__group__funcmacro__events.html#g405678e40da45711c720b72cda7f1470" title="Use this macro in a source file to start listing static event handlers for a specific...">BEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>)
        EVT_CLOSE(MyFrame::OnClose)
        EVT_MENU(Minimal_Start,  MyFrame::DoStartThread)
        EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_MYTHREAD_UPDATE, MyFrame::OnThreadUpdate)
        EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_MYTHREAD_COMPLETED, MyFrame::OnThreadCompletion)
    <a class="code" href="group__group__funcmacro__events.html#g5df87bbe7c82edea87b2aeaa6dc57cfd" title="Use this macro in a source file to end listing static event handlers for a specific...">END_EVENT_TABLE</a>()

    <a class="code" href="group__group__funcmacro__events.html#g09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>)
    <a class="code" href="group__group__funcmacro__events.html#g09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>)

    <span class="keywordtype">void</span> MyFrame::DoStartThread()
    {
        m_pThread = <span class="keyword">new</span> MyThread(<span class="keyword">this</span>);

        <span class="keywordflow">if</span> ( m_pThread-&gt;Create() != <a class="code" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2d1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
        {
            <a class="code" href="group__group__funcmacro__log.html#g0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't create the thread!"</span>);
            <span class="keyword">delete</span> m_pThread;
            m_pThread = NULL;
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">if</span> (m_pThread-&gt;Run() != <a class="code" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2d1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
            {
                <a class="code" href="group__group__funcmacro__log.html#g0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't create the thread!"</span>);
                <span class="keyword">delete</span> m_pThread;
                m_pThread = NULL;
            }

            <span class="comment">// after the call to wxThread::Run(), the m_pThread pointer is "unsafe":</span>
            <span class="comment">// at any moment the thread may cease to exist (because it completes its work).</span>
            <span class="comment">// To avoid dangling pointers OnThreadExit() will set m_pThread</span>
            <span class="comment">// to NULL when the thread dies.</span>
        }
    }

    <a class="code" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a> <a class="code" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">MyThread::Entry</a>()
    {
        <span class="keywordflow">while</span> (!TestDestroy())
        {
            <span class="comment">// ... do a bit of work...</span>

            <a class="code" href="group__group__funcmacro__events.html#ge921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_UPDATE));
        }

        <span class="comment">// signal the event handler that this thread is going to be destroyed</span>
        <span class="comment">// NOTE: here we assume that using the m_pHandler pointer is safe,</span>
        <span class="comment">//       (in this case this is assured by the MyFrame destructor)</span>
        <a class="code" href="group__group__funcmacro__events.html#ge921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED));

        <span class="keywordflow">return</span> (<a class="code" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a>)0;     <span class="comment">// success</span>
    }

    MyThread::~MyThread()
    {
        <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pHandler-&gt;m_pThreadCS);

        <span class="comment">// the thread is being destroyed; make sure not to leave dangling pointers around</span>
        m_pHandler-&gt;m_pThread = NULL;
    }

    <span class="keywordtype">void</span> MyFrame::OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>&amp;)
    {
        wxMessageOutputDebug().Printf(<span class="stringliteral">"MYFRAME: MyThread exited!\n"</span>);
    }

    <span class="keywordtype">void</span> MyFrame::OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionalities to wxCommandEvent coinceived for inter-threads...">wxThreadEvent</a>&amp;)
    {
        wxMessageOutputDebug().Printf(<span class="stringliteral">"MYFRAME: MyThread update...\n"</span>);
    }

    <span class="keywordtype">void</span> MyFrame::DoPauseThread()
    {
        <span class="comment">// anytime we access the m_pThread pointer we must ensure that it won't</span>
        <span class="comment">// be modified in the meanwhile; since only a single thread may be</span>
        <span class="comment">// inside a given critical section at a given time, the following code</span>
        <span class="comment">// is safe:</span>
        <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);

        <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span>
        {
            <span class="comment">// without a critical section, once reached this point it may happen</span>
            <span class="comment">// that the OS scheduler gives control to the MyThread::Entry() function,</span>
            <span class="comment">// which in turn may return (because it completes its work) making</span>
            <span class="comment">// invalid the m_pThread pointer</span>

            <span class="keywordflow">if</span> (m_pThread-&gt;Pause() != <a class="code" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2d1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
                <a class="code" href="group__group__funcmacro__log.html#g0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't pause the thread!"</span>);
        }
    }

    <span class="keywordtype">void</span> MyFrame::OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;)
    {
        {
            <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);

            <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span>
            {
                m_out.Printf(<span class="stringliteral">"MYFRAME: deleting thread"</span>);

                <span class="keywordflow">if</span> (m_pThread-&gt;Delete() != <a class="code" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2d1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
                    <a class="code" href="group__group__funcmacro__log.html#g0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't delete the thread!"</span>);
            }
        }       <span class="comment">// exit from the critical section to give the thread</span>
                <span class="comment">// the possibility to enter its destructor</span>
                <span class="comment">// (which is guarded with m_pThreadCS critical section!)</span>

        <span class="keywordflow">while</span> (1)
        {
            { <span class="comment">// was the ~MyThread() function executed?</span>
                <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);
                <span class="keywordflow">if</span> (!m_pThread) <span class="keywordflow">break</span>;
            }

            <span class="comment">// wait for thread completion</span>
            <a class="code" href="classwx_thread.html#7077fa46ffef0fd1d023628776598335" title="Return the thread object for the calling thread.">wxThread::This</a>()-&gt;<a class="code" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep</a>(1);
        }

        Destroy();
    }
</pre></div><p>
For a more detailed and comprehensive example, see <a class="el" href="page_samples.html#page_samples_thread">Thread Sample</a>. For a simpler way to share data and synchronization objects between the main and the secondary thread see <a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread...">wxThreadHelper</a>.<p>
Conversely, <b>joinable</b> threads do not delete themselves when they are done processing and as such are safe to create on the stack. Joinable threads also provide the ability for one to get value it returned from <a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> through <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a>. You shouldn't hurry to create all the threads joinable, however, because this has a disadvantage as well: you <b>must</b> <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself if you did not create it on the stack. In contrast, detached threads are of the "fire-and-forget" kind: you only have to start a detached thread and it will terminate and destroy itself.<h2><a class="anchor" name="thread_deletion">
wxThread Deletion</a></h2>
Regardless of whether it has terminated or not, you should call <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> on a <b>joinable</b> thread to release its memory, as outlined in <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a>. If you created a joinable thread on the heap, remember to delete it manually with the <code>delete</code> operator or similar means as only detached threads handle this type of memory management.<p>
Since <b>detached</b> threads delete themselves when they are finished processing, you should take care when calling a routine on one. If you are certain the thread is still running and would like to end it, you may call <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> to gracefully end it (which implies that the thread will be deleted after that call to <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a>). It should be implied that you should <b>never</b> attempt to delete a detached thread with the <code>delete</code> operator or similar means.<p>
As mentioned, <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> or <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> functions attempt to gracefully terminate a joinable and a detached thread, respectively. They do this by waiting until the thread in question calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> or ends processing (i.e. returns from <a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">wxThread::Entry</a>).<p>
Obviously, if the thread does call <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> and does not end, the thread which called <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> or <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> will come to halt. This is why it's important to call <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> in the <a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> routine of your threads as often as possible and immediately exit when it returns <span class="literal">true</span>.<p>
As a last resort you can end the thread immediately through <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a>. It is strongly recommended that you do not do this, however, as it does not free the resources associated with the object (although the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object of detached threads will still be deleted) and could leave the C runtime library in an undefined state.<h2><a class="anchor" name="thread_secondary">
wxWidgets Calls in Secondary Threads</a></h2>
All threads other than the "main application thread" (the one running <a class="el" href="classwx_app_console.html#99953775a2fd83fa2456e390779afe15" title="This must be provided by the application, and will usually create the application&#39;s...">wxApp::OnInit()</a> or the one your main function runs in, for example) are considered "secondary threads". These include all threads created by <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> or the corresponding constructors.<p>
GUI calls, such as those to a <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> or <a class="el" href="classwx_bitmap.html" title="This class encapsulates the concept of a platform-dependent bitmap, either monochrome...">wxBitmap</a> are explicitly not safe at all in secondary threads and could end your application prematurely. This is due to several reasons, including the underlying native API and the fact that <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> does not run a GUI event loop similar to other APIs as MFC.<p>
A workaround for some wxWidgets ports is calling wxMutexGUIEnter() before any GUI calls and then calling wxMutexGUILeave() afterwords. However, the recommended way is to simply process the GUI calls in the main thread through an event that is posted by <a class="el" href="group__group__funcmacro__events.html#ge921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent()</a>. This does not imply that calls to these classes are thread-safe, however, as most wxWidgets classes are not thread-safe, including <a class="el" href="classwx_string.html" title="The wxString class has been completely rewritten for wxWidgets 3.0 and this change...">wxString</a>.<h2><a class="anchor" name="thread_poll">
Don't Poll a wxThread</a></h2>
A common problem users experience with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> is that in their main thread they will check the thread every now and then to see if it has ended through <a class="el" href="classwx_thread.html#0230733ffdc8f7603082dd2ca86b8cdd" title="Returns true if the thread is running.">IsRunning()</a>, only to find that their application has run into problems because the thread is using the default behavior (i.e. it's <b>detached</b>) and has already deleted itself. Naturally, they instead attempt to use joinable threads in place of the previous behavior. However, polling a <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> for when it has ended is in general a bad idea - in fact calling a routine on any running <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> should be avoided if possible. Instead, find a way to notify yourself when the thread has ended.<p>
Usually you only need to notify the main thread, in which case you can post an event to it via <a class="el" href="group__group__funcmacro__events.html#ge921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent()</a>. In the case of secondary threads you can call a routine of another class when the thread is about to complete processing and/or set the value of a variable, possibly using mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it...">wxMutex</a>) and/or other synchronization means if necessary.<p>
<h2></h2>
<p>
<div><span class="lib">Library:</span>&nbsp;&nbsp;<span class="lib_text"><a class="el" href="page_libs.html#page_libs_wxbase">wxBase</a></span></div><p>
<div><span class="category">Category:</span>&nbsp;&nbsp;<span class="category_text"><a class="el" href="group__group__class__threading.html">Threading</a></span></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread...">wxThreadHelper</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it...">wxMutex</a>, <a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects...">wxCondition</a>, <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>, <a class="el" href="overview_thread.html">Multithreading Overview</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The return type for the thread functions.  <a href="#de9497fa072fe19481086e6486dcc028"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#afdb64801bd4d595ad0956f71d5791f0">wxThread</a> (<a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> kind=wxTHREAD_DETACHED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor creates a new detached (default) or joinable C++ thread object.  <a href="#afdb64801bd4d595ad0956f71d5791f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#48c37f3555eb99cca9d9f3594fed5793">~wxThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor frees the resources associated with the thread.  <a href="#48c37f3555eb99cca9d9f3594fed5793"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create</a> (unsigned int stackSize=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new thread.  <a href="#88051a33aa3fa9ca9392ac7d47b43cf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea">Delete</a> (void **rc=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calling <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> or when it finishes processing.  <a href="#0947c630f586528617384499d5e84aea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">wxThreadIdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#2c9db3ca1d37d8ed921e78c31acd9bb4">GetId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e.  <a href="#2c9db3ca1d37d8ed921e78c31acd9bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#1fc5fa753cf2bc0ec63ff16825a144b2">GetKind</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the thread kind as it was given in the ctor.  <a href="#1fc5fa753cf2bc0ec63ff16825a144b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#785ac6add565d789481f8a9dfde5c229">GetPriority</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the priority of the thread, between zero and 100.  <a href="#785ac6add565d789481f8a9dfde5c229"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#dc6cf71c426b1da03c6ca4b7f7da8aab">IsAlive</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is alive (i.e.  <a href="#dc6cf71c426b1da03c6ca4b7f7da8aab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#315c2abb553ba7e17ab2d5b2a0728e73">IsDetached</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one.  <a href="#315c2abb553ba7e17ab2d5b2a0728e73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#34328ecb720a1066971fb5e48cd84b6f">IsPaused</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is paused.  <a href="#34328ecb720a1066971fb5e48cd84b6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#0230733ffdc8f7603082dd2ca86b8cdd">IsRunning</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is running.  <a href="#0230733ffdc8f7603082dd2ca86b8cdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediately terminates the target thread.  <a href="#2cbff8b3b0a93ab82f212c02f38a1ef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba">Pause</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspends the thread.  <a href="#8c6d835578dde71dd2c241c38336a4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#fe81d37cd6cb6d5eb142773fb2c94562">Resume</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>.  <a href="#fe81d37cd6cb6d5eb142773fb2c94562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0">Run</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the thread execution.  <a href="#5d894750ffaac8fc42ee85aeff8bb4c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#6236828fe98e81103219a519fbd7091d">SetPriority</a> (unsigned int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the priority of the thread, between 0 and 100.  <a href="#6236828fe98e81103219a519fbd7091d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> will work.  <a href="#9a3acec44b06b2a2430c5659991a3eac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab">Wait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error.  <a href="#fbc4e78632fca678377b47a66956e5ab"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#21ccbc2f91bed8d65aeada49a7f8335d">GetCPUCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of system CPUs or -1 if the value is unknown.  <a href="#21ccbc2f91bed8d65aeada49a7f8335d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static wxThreadIdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#414fecfb855a7e12088bb0fa54ebd330">GetCurrentId</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the platform specific thread ID of the current thread as a long.  <a href="#414fecfb855a7e12088bb0fa54ebd330"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#1ee917ef87f986ba3b2ee26e620378e4">IsMain</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the calling thread is the main application thread.  <a href="#1ee917ef87f986ba3b2ee26e620378e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#09dfe3800bbfad53be303a4608d52959">SetConcurrency</a> (size_t level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the thread concurrency level for this process.  <a href="#09dfe3800bbfad53be303a4608d52959"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6">Sleep</a> (unsigned long milliseconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses the thread execution for the given amount of time.  <a href="#9ae47b39270c54dba5534af31f885ec6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classwx_thread.html">wxThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#7077fa46ffef0fd1d023628776598335">This</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the thread object for the calling thread.  <a href="#7077fa46ffef0fd1d023628776598335"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#7a36099bab2d4be9d72cfd4cf76e8aa6">Yield</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the rest of the thread's time-slice to the system allowing the other threads to run.  <a href="#7a36099bab2d4be9d72cfd4cf76e8aa6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d">Entry</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the entry point of the thread.  <a href="#f50fa7d3ac55002e367e79989b9cbc5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#888b9b94f64a2b61bd4740de1149e6e2">Exit</a> (<a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a> exitcode=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class.  <a href="#888b9b94f64a2b61bd4740de1149e6e2"></a><br></td></tr>
</table>

<p>
<a href="classwx_thread-members.html">List of all members.</a><hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="de9497fa072fe19481086e6486dcc028"></a><!-- doxytag: member="wxThread::ExitCode" ref="de9497fa072fe19481086e6486dcc028" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">wxThread::ExitCode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The return type for the thread functions. 
<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="afdb64801bd4d595ad0956f71d5791f0"></a><!-- doxytag: member="wxThread::wxThread" ref="afdb64801bd4d595ad0956f71d5791f0" args="(wxThreadKind kind=wxTHREAD_DETACHED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThread::wxThread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>wxTHREAD_DETACHED</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This constructor creates a new detached (default) or joinable C++ thread object. 
<p>
It does not create or start execution of the real thread - for this you should use the <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> and <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> methods.<p>
The possible values for <em>kind</em> parameters are:<ul>
<li><b>wxTHREAD_DETACHED</b> - Creates a detached thread.</li><li><b>wxTHREAD_JOINABLE</b> - Creates a joinable thread. </li></ul>

</div>
</div><p>
<a class="anchor" name="48c37f3555eb99cca9d9f3594fed5793"></a><!-- doxytag: member="wxThread::~wxThread" ref="48c37f3555eb99cca9d9f3594fed5793" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual wxThread::~wxThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor frees the resources associated with the thread. 
<p>
Notice that you should never delete a detached thread -- you may only call <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> on it or wait until it terminates (and auto destructs) itself.<p>
Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> and <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> functions will not delete the C++ thread object. It is also safe to allocate them on stack. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="88051a33aa3fa9ca9392ac7d47b43cf4"></a><!-- doxytag: member="wxThread::Create" ref="88051a33aa3fa9ca9392ac7d47b43cf4" args="(unsigned int stackSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Create           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stackSize</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new thread. 
<p>
The thread object is created in the suspended state, and you should call <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix system without <code>pthread_attr_setstacksize</code>).<p>
If you do not specify the stack size,the system's default value is used.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is a good idea to explicitly specify a value as systems' default values vary from just a couple of KB on some systems (BSD and OS/2 systems) to one or several MB (Windows, Solaris, Linux). So, if you have a thread that requires more than just a few KB of memory, you will have mysterious problems on some platforms but not on the common ones. On the other hand, just indicating a large stack size by default will give you performance issues on those systems with small default stack since those typically use fully committed memory for the stack. On the contrary, if you use a lot of threads (say several hundred), virtual adress space can get tight unless you explicitly specify a smaller amount of thread stack space for each thread.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>One of:<ul>
<li><b>wxTHREAD_NO_ERROR</b> - No error.</li><li><b>wxTHREAD_NO_RESOURCE</b> - There were insufficient resources to create the thread.</li><li><b>wxTHREAD_NO_RUNNING</b> - The thread is already running </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0947c630f586528617384499d5e84aea"></a><!-- doxytag: member="wxThread::Delete" ref="0947c630f586528617384499d5e84aea" args="(void **rc=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Delete           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>rc</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> or when it finishes processing. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function works on a joinable thread but in that case makes the <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> function of the thread return <span class="literal">true</span> and then waits for its completion (i.e. it differs from <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> because it asks the thread to terminate before waiting).</dd></dl>
See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine. 
</div>
</div><p>
<a class="anchor" name="f50fa7d3ac55002e367e79989b9cbc5d"></a><!-- doxytag: member="wxThread::Entry" ref="f50fa7d3ac55002e367e79989b9cbc5d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Entry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the entry point of the thread. 
<p>
This function is pure virtual and must be implemented by any derived class. The thread execution will start here.<p>
The returned value is the thread exit code which is only useful for joinable threads and is the value returned by <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a>. This function is called by wxWidgets itself and should never be called directly. 
</div>
</div><p>
<a class="anchor" name="888b9b94f64a2b61bd4740de1149e6e2"></a><!-- doxytag: member="wxThread::Exit" ref="888b9b94f64a2b61bd4740de1149e6e2" args="(ExitCode exitcode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::Exit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td>
          <td class="paramname"> <em>exitcode</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class. 
<p>
It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread.<p>
This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads. OnExit() will be called just before exiting. 
</div>
</div><p>
<a class="anchor" name="21ccbc2f91bed8d65aeada49a7f8335d"></a><!-- doxytag: member="wxThread::GetCPUCount" ref="21ccbc2f91bed8d65aeada49a7f8335d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int wxThread::GetCPUCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of system CPUs or -1 if the value is unknown. 
<p>
For multi-core systems the returned value is typically the total number of <em>cores</em>, since the OS usually abstract a single N-core CPU as N different cores.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classwx_thread.html#09dfe3800bbfad53be303a4608d52959" title="Sets the thread concurrency level for this process.">SetConcurrency()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="414fecfb855a7e12088bb0fa54ebd330"></a><!-- doxytag: member="wxThread::GetCurrentId" ref="414fecfb855a7e12088bb0fa54ebd330" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static wxThreadIdType wxThread::GetCurrentId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the platform specific thread ID of the current thread as a long. 
<p>
This can be used to uniquely identify threads, even if they are not wxThreads. 
</div>
</div><p>
<a class="anchor" name="2c9db3ca1d37d8ed921e78c31acd9bb4"></a><!-- doxytag: member="wxThread::GetId" ref="2c9db3ca1d37d8ed921e78c31acd9bb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThreadIdType wxThread::GetId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. 
<p>
the thread identifiers may be reused). 
</div>
</div><p>
<a class="anchor" name="1fc5fa753cf2bc0ec63ff16825a144b2"></a><!-- doxytag: member="wxThread::GetKind" ref="1fc5fa753cf2bc0ec63ff16825a144b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> wxThread::GetKind           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the thread kind as it was given in the ctor. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>2.9.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="785ac6add565d789481f8a9dfde5c229"></a><!-- doxytag: member="wxThread::GetPriority" ref="785ac6add565d789481f8a9dfde5c229" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int wxThread::GetPriority           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the priority of the thread, between zero and 100. 
<p>
The following priorities are defined:<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li><li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li><li><b>WXTHREAD_MAX_PRIORITY:</b> 100 </li></ul>

</div>
</div><p>
<a class="anchor" name="dc6cf71c426b1da03c6ca4b7f7da8aab"></a><!-- doxytag: member="wxThread::IsAlive" ref="dc6cf71c426b1da03c6ca4b7f7da8aab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsAlive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is alive (i.e. 
<p>
started and not terminating).<p>
Note that this function can only safely be used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is no longer alive, it is not possible to call this function because the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object no longer exists. 
</div>
</div><p>
<a class="anchor" name="315c2abb553ba7e17ab2d5b2a0728e73"></a><!-- doxytag: member="wxThread::IsDetached" ref="315c2abb553ba7e17ab2d5b2a0728e73" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsDetached           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one. 
<p>

</div>
</div><p>
<a class="anchor" name="1ee917ef87f986ba3b2ee26e620378e4"></a><!-- doxytag: member="wxThread::IsMain" ref="1ee917ef87f986ba3b2ee26e620378e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::IsMain           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the calling thread is the main application thread. 
<p>

</div>
</div><p>
<a class="anchor" name="34328ecb720a1066971fb5e48cd84b6f"></a><!-- doxytag: member="wxThread::IsPaused" ref="34328ecb720a1066971fb5e48cd84b6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsPaused           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is paused. 
<p>

</div>
</div><p>
<a class="anchor" name="0230733ffdc8f7603082dd2ca86b8cdd"></a><!-- doxytag: member="wxThread::IsRunning" ref="0230733ffdc8f7603082dd2ca86b8cdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsRunning           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is running. 
<p>
This method may only be safely used for joinable threads, see the remark in <a class="el" href="classwx_thread.html#dc6cf71c426b1da03c6ca4b7f7da8aab" title="Returns true if the thread is alive (i.e.">IsAlive()</a>. 
</div>
</div><p>
<a class="anchor" name="2cbff8b3b0a93ab82f212c02f38a1ef4"></a><!-- doxytag: member="wxThread::Kill" ref="2cbff8b3b0a93ab82f212c02f38a1ef4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Kill           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Immediately terminates the target thread. 
<p>
<b>"This function is dangerous and should be used with extreme care"</b> (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> for detached threads or <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> for joinable threads instead.<p>
For detached threads <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself to avoid memory leaks.<p>
In neither case OnExit() of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself.<p>
It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) -- if you do it, a <b>wxTHREAD_NOT_RUNNING</b> error will be returned. 
</div>
</div><p>
<a class="anchor" name="8c6d835578dde71dd2c241c38336a4ba"></a><!-- doxytag: member="wxThread::Pause" ref="8c6d835578dde71dd2c241c38336a4ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Pause           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspends the thread. 
<p>
Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to...">TestDestroy()</a> for the next time (hence, if the thread doesn't call it at all, it won't be suspended).<p>
This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="fe81d37cd6cb6d5eb142773fb2c94562"></a><!-- doxytag: member="wxThread::Resume" ref="fe81d37cd6cb6d5eb142773fb2c94562" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Resume           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>. 
<p>
This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="5d894750ffaac8fc42ee85aeff8bb4c0"></a><!-- doxytag: member="wxThread::Run" ref="5d894750ffaac8fc42ee85aeff8bb4c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Run           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the thread execution. 
<p>
Should be called after <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a>.<p>
Note that once you <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> a <b>detached</b> thread, <em>any</em> function call you do on the thread pointer (you must allocate it on the heap) is <em>"unsafe"</em>; i.e. the thread may have terminated at any moment after <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> and your pointer may be dangling. See <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a> for an example of safe manipulation of detached threads.<p>
This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="09dfe3800bbfad53be303a4608d52959"></a><!-- doxytag: member="wxThread::SetConcurrency" ref="09dfe3800bbfad53be303a4608d52959" args="(size_t level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::SetConcurrency           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the thread concurrency level for this process. 
<p>
This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for <em>level</em> may be used to set the default one.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><span class="literal">true</span> on success or <span class="literal">false</span> otherwise (for example, if this function is not implemented for this platform -- currently everything except Solaris). </dd></dl>

</div>
</div><p>
<a class="anchor" name="6236828fe98e81103219a519fbd7091d"></a><!-- doxytag: member="wxThread::SetPriority" ref="6236828fe98e81103219a519fbd7091d" args="(unsigned int priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::SetPriority           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>priority</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the priority of the thread, between 0 and 100. 
<p>
It can only be set after calling <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> but before calling <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a>.<p>
The following priorities are defined:<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li><li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li><li><b>WXTHREAD_MAX_PRIORITY:</b> 100 </li></ul>

</div>
</div><p>
<a class="anchor" name="9ae47b39270c54dba5534af31f885ec6"></a><!-- doxytag: member="wxThread::Sleep" ref="9ae47b39270c54dba5534af31f885ec6" args="(unsigned long milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Sleep           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pauses the thread execution for the given amount of time. 
<p>
This is the same as <a class="el" href="group__group__funcmacro__time.html#g66778879349f76fd833902d3767006fa" title="Sleeps for the specified number of milliseconds.">wxMilliSleep()</a>. 
</div>
</div><p>
<a class="anchor" name="9a3acec44b06b2a2430c5659991a3eac"></a><!-- doxytag: member="wxThread::TestDestroy" ref="9a3acec44b06b2a2430c5659991a3eac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wxThread::TestDestroy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a> will work. 
<p>
If it returns <span class="literal">true</span>, the thread should exit as soon as possible. Notice that under some platforms (POSIX), implementation of <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> also relies on this function being called, so not calling it would prevent both stopping and suspending thread from working. 
</div>
</div><p>
<a class="anchor" name="7077fa46ffef0fd1d023628776598335"></a><!-- doxytag: member="wxThread::This" ref="7077fa46ffef0fd1d023628776598335" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classwx_thread.html">wxThread</a>* wxThread::This           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the thread object for the calling thread. 
<p>
<span class="literal">NULL</span> is returned if the calling thread is the main (GUI) thread, but <a class="el" href="classwx_thread.html#1ee917ef87f986ba3b2ee26e620378e4" title="Returns true if the calling thread is the main application thread.">IsMain()</a> should be used to test whether the thread is really the main one because <span class="literal">NULL</span> may also be returned for the thread not created with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class. Generally speaking, the return value for such a thread is undefined. 
</div>
</div><p>
<a class="anchor" name="fbc4e78632fca678377b47a66956e5ab"></a><!-- doxytag: member="wxThread::Wait" ref="fbc4e78632fca678377b47a66956e5ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwx_thread.html#de9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Wait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#f50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error. 
<p>
Notice that, unlike <a class="el" href="classwx_thread.html#0947c630f586528617384499d5e84aea" title="Calling Delete() gracefully terminates a detached thread, either when the thread...">Delete()</a>, this function doesn't cancel the thread in any way so the caller waits for as long as it takes to the thread to exit.<p>
You can only <a class="el" href="classwx_thread.html#fbc4e78632fca678377b47a66956e5ab" title="Waits for a joinable thread to terminate and returns the value the thread returned...">Wait()</a> for <b>joinable</b> (not detached) threads.<p>
This function can only be called from another thread context.<p>
See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine. 
</div>
</div><p>
<a class="anchor" name="7a36099bab2d4be9d72cfd4cf76e8aa6"></a><!-- doxytag: member="wxThread::Yield" ref="7a36099bab2d4be9d72cfd4cf76e8aa6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Yield           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give the rest of the thread's time-slice to the system allowing the other threads to run. 
<p>
Note that using this function is <b>strongly</b> discouraged, since in many cases it indicates a design weakness of your threading model (as does using <a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> functions).<p>
Threads should use the CPU in an efficient manner, i.e. they should do their current work efficiently, then as soon as the work is done block on a wakeup event (<a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects...">wxCondition</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it...">wxMutex</a>, select(), poll(), ...) which will get signalled e.g. by other threads or a user device once further thread work is available. Using <a class="el" href="classwx_thread.html#7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads...">Yield()</a> or <a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> indicates polling-type behaviour, since we're fuzzily giving up our timeslice and wait until sometime later we'll get reactivated, at which time we realize that there isn't really much to do and <a class="el" href="classwx_thread.html#7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads...">Yield()</a> again...<p>
The most critical characteristic of <a class="el" href="classwx_thread.html#7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads...">Yield()</a> is that it's operating system specific: there may be scheduler changes which cause your thread to not wake up relatively soon again, but instead many seconds later, causing huge performance issues for your application.<p>
<b> With a well-behaving, CPU-efficient thread the operating system is likely to properly care for its reactivation the moment it needs it, whereas with non-deterministic, Yield-using threads all bets are off and the system scheduler is free to penalize them drastically</b>, and this effect gets worse with increasing system load due to less free CPU resources available. You may refer to various Linux kernel <code>sched_yield</code> discussions for more information.<p>
See also <a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a>. 
</div>
</div><p>
</div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Fri Sep 4 06:59:32 2009</tt> by <a href="http://www.doxygen.org">Doxygen</a> 1.5.8</p></td>
    <td valign="middle" align="right"><p>[ <a href="#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
